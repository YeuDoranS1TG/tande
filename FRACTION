/*
#include<bits/stdc++.h>
using namespace std;
#define maxN 1000000
int d[maxN+5]={0};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //freopen("FRACTION.INP","r",stdin);
    //freopen("FRACTION.OUT","w",stdout);
    int T;
    cin>>T;
    for (int a=2;a*a<=maxN;++a){
        if (d[a]==0){
            for (int b=a;a*b<=maxN;++b){
                d[a*b]=a;
            }
        }
    }
    while (T--){
        int n; cin>>n;
        map<int,int>tu;
        vector<int>mau;
        for (int i=1;i<=2*n;++i){
            int res; cin>>res;
            if (i<=n){
                while (res>1){
                    int p=d[res];
                    if (p==0) p=res;
                    while (res%p==0){
                        ++tu[p];
                        res/=p;
                    }
                }
            }
            else {
                while (res>1){
                    int p=d[res];
                    if (p==0) p=res;
                    while (res%p==0){
                        if (tu[p]==0){
                            if (p!=5 && p!=2) mau.push_back(p);
                        }
                        res/=p;
                    }
                }
            }
        }
        if (mau.size()>0) cout<<"repeating"<<'\n';
        else cout<<"finite"<<'\n';
    }
    return 0;
}
*/
#include<bits/stdc++.h>
using namespace std;
#define maxN 1000000
int d[maxN+5]={0};
void factorial(int res, map<int,int> &mp, int x){
    while (res>1){
        int p=d[res];
        if (p==0) p=res;
        int cnt=0;
        while (res%p==0){
            ++cnt;
            res/=p;
        }
        mp[p]+=x*cnt;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    freopen("FRACTION.INP","r",stdin);
    freopen("FRACTION.OUT","w",stdout);
    int T;
    cin>>T;
    for (int a=2;a*a<=maxN;++a){
        if (d[a]==0){
            for (int b=a;a*b<=maxN;++b){
                d[a*b]=a;
            }
        }
    }
    while (T--){
        int n; cin>>n;
        map<int,int>a;
        for (int i=0;i<n;++i){
            int res;
            cin>>res;
            factorial(res,a,1);
        }
        for (int i=0;i<n;++i){
            int res;
            cin>>res;
            factorial(res,a,-1);
        }
        bool ok=false;
        for (auto &v:a){
            if (v.second<0 && v.first!=2 && v.first!=5){
                ok=true;
            }
        }
        if (ok) cout<<"repeating"<<'\n';
        else cout<<"finite"<<'\n';
    }
    return 0;
}
/*
PHÂN SỐ 
Số hữu tỉ có thể được biểu diễn dưới dạng phân số 𝑋/𝑌, trong đó 𝑋 và 𝑌(𝑌 ≠ 0) là các số nguyên. Chu kỳ 
của một số hữu tỉ là đoạn con ngắn nhất sau dấu phẩy được lặp lại vô hạn lần. Ví dụ, phân số 7/30 =
 0,2333. ., kí hiệu 0,2(3), là số hữu tỉ có số 3 được lặp lại vô hạn lần nên được gọi là chu kì.  
Dựa vào chu kỳ, số hữu tỉ được phân thành 2 loại: thập phân hữu hạn hoặc vô hạn tuần hoàn. - 
Số thập phân vô hạn tuần hoàn là số hữu tỉ có chu kỳ lớn hơn 0. Ví dụ: 116/495 = 0,2(34). - 
Số thập phân hữu hạn là số hữu tỉ có chu kỳ bằng 0. Ví dụ: 3/20 = 0,15(0); 4/1 = 4,(0). 
Yêu cầu: Cho 2 ×𝑛 số nguyên dương 𝑎1,𝑎2,…,𝑎𝑛,𝑏1,𝑏2,…,𝑏𝑛. Đặt 𝑋 = 𝑎1 ×𝑎2 ×…×𝑎𝑛 và 𝑌 =
 ⁄ là thập phân hữu hạn hay vô hạn tuần hoàn. Cho biết phân số 𝑋/𝑌
 Dữ liệu: Vào từ tập tin văn bản FRACTION.INP - - 
Dòng đầu tiên chứa số nguyên dương 𝑇 (1 ≤ 𝑇 ≤ 10) là số lượng bộ dữ liệu. 
T dòng sau, số đầu tiên mỗi dòng là 𝑛, tiếp theo là dãy gồm 2 × 𝑛 số nguyên dương 𝑎1,𝑎2,…,𝑎𝑛, b1, 𝑏2, …,𝑏𝑛 mô tả một bộ dữ liệu. Các số trên cùng một dòng cách nhau bởi dấu cách. 
Kết quả: Ghi ra tập tin văn bản FRACTION.OUT gồm 𝑇 dòng, mỗi dòng ghi "finite" hoặc 
"repeating" tương ứng với câu trả lời phân số 𝑋/𝑌
 ⁄ là thập phân hữu hạn hay vô hạn tuần hoàn. 

Ví dụ: 
FRACTION.INP
4 
2 1 7 5 6 
1 3 20 
1 4 1 
1 116 495 

FRACTION.OUT
repeating 
finite 
finite 
repeating 

Giải thích 
7/30    = 0,2(3) 
3/20    = 0,15(0) 
4/1     = 4,(0) 
116/495 = 0,2(34) 

Giới hạn: Đặt 𝑉 = max (𝑎1,𝑎2,…,𝑎𝑛,𝑏1,𝑏2,…,𝑏𝑛). - - - - 
Subtask 1 (25%): 𝑛 = 1, 𝑉 ≤ 106 
Subtask 2 (25%): 𝑛 ≤ 104, 𝑉 ≤ 106 
Subtask 3 (25%): 𝑛 ≤ 105,𝑉 ≤ 105 
Subtask 4 (25%): 𝑛 ≤ 105, 𝑉 ≤ 106 
*/
